#!/usr/bin/env bash

#
# Git Worktree Tmux Sessionizer
#
# WHAT THIS SCRIPT DOES:
#   This script helps you manage git worktrees inside ANY git repository
#   (bare or non-bare). It uses fzf to show you a menu with:
#
#     [worktree]  - Worktrees that already exist on disk. Selecting one
#                   will jump you straight into a tmux session for it.
#
#     [branch]    - Branches that do NOT have a worktree yet. Selecting one
#                   will create a new worktree for that branch, then open
#                   a tmux session in it.
#
#   Each entry shows: author, relative date, and last commit message.
#
#   If you type a name that doesn't match ANY existing branch or worktree
#   and press Enter, it will immediately create a new branch + worktree
#   with that name (no extra prompts).
#
#   Press Ctrl-D on a [worktree] entry to DELETE it (removes the worktree
#   directory and unregisters it from git). The fzf menu refreshes after.
#
#   Worktrees are created ONE LEVEL UP from the repo, named as
#   projectname_branchname:
#     ~/code/my-project/                   <-- repo (bare or non-bare)
#     ~/code/my-project_main/              <-- worktree for 'main' branch
#     ~/code/my-project_feature-x/         <-- worktree for 'feature-x' branch
#
#   Each worktree gets its own tmux SESSION.
#
# KEYBINDINGS (inside fzf):
#   Enter   - Select / open the worktree or branch
#   Ctrl-D  - Delete the selected worktree (only works on [worktree] entries)
#   Esc     - Cancel and exit
#
# USAGE:
#   ./git-worktree-sessionizer.sh           # Opens fzf menu to pick
#   ./git-worktree-sessionizer.sh <branch>  # Skips fzf, goes straight to branch
#
# REQUIREMENTS:
#   - git, tmux, fzf
#   - Must be run from inside a git repository

set -eo pipefail

# INFO: Verify we're inside a git repo
git rev-parse --git-dir &>/dev/null || {
    notify-send -u critical -t 6000 "Git Worktree" "Not inside a git repository." -i git
    exit 1
}

# INFO: Resolve REPO_ROOT to the MAIN repo (not current worktree)
# The first line of `git worktree list` is ALWAYS the main working tree
# regardless of which worktree you're currently inside.
REPO_ROOT=$(git worktree list | head -n1 | awk '{print $1}')
REPO_ROOT=$(cd "$REPO_ROOT" && pwd)

PARENT_DIR=$(dirname "$REPO_ROOT")
PROJECT_NAME=$(basename "$REPO_ROOT")

# Detect which branch the current worktree is on, so we can hide it from the
# fzf list (no point showing the one you're already in).
# `git symbolic-ref --short HEAD` returns the branch name (e.g. "main").
# If we're in the bare repo root or detached HEAD, this returns empty — that's fine.
CURRENT_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")

# INFO: Ensure remote fetch refspec is configured
current_fetch=$(git config --get remote.origin.fetch 2>/dev/null || echo "")
if [[ "$current_fetch" != "+refs/heads/*:refs/remotes/origin/*" ]]; then
    git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    notify-send -t 6000 "Git Worktree" "First-time setup: fetching all branches from origin..." -i folder-download
    git fetch origin --quiet 2>/dev/null || true
fi

# Background fetch — updates remote refs for next run without blocking this one
(git fetch origin --quiet 2>/dev/null &) &>/dev/null
disown 2>/dev/null || true

SEP="|"

get_branch_info() {
    local branch="$1"
    local format_str="%an${SEP}%ar${SEP}%s"
    local info

    info=$(git log -1 --format="$format_str" "$branch" 2>/dev/null) ||
    info=$(git log -1 --format="$format_str" "origin/$branch" 2>/dev/null) ||
    info="unknown${SEP}unknown${SEP}no commits"

    echo "$info" | awk -F"${SEP}" '{
        msg = substr($3, 1, 50)
        printf "%s'"${SEP}"'%s'"${SEP}"'%s", $1, $2, msg
    }'
}

# This is a function because we need to rebuild it after deleting a worktree.
build_fzf_list() {
    # Gather existing worktrees
    # We need to re-declare these each time since worktrees may have been deleted.
    declare -A _worktree_map
    local _existing_wt=()

    while IFS= read -r line; do
        local wt_path wt_branch
        wt_path=$(echo "$line" | awk '{print $1}')
        wt_branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')

        if [[ -n "$wt_branch" ]]; then
            [[ "$wt_path" == "$REPO_ROOT" ]] && continue
            _worktree_map["$wt_branch"]="$wt_path"
            _existing_wt+=("$wt_branch")
        fi
    done < <(git worktree list)

    # Gather and deduplicate branches
    local _all_branches=()
    declare -A _seen

    while IFS= read -r branch; do
        branch=$(echo "$branch" | sed 's/^[* ] //' | xargs)
        [[ -z "$branch" ]] && continue
        [[ "$branch" == *"HEAD"* ]] && continue

        local short="${branch#origin/}"
        if [[ -z "${_seen[$short]+_}" ]]; then
            _seen["$short"]=1
            _all_branches+=("$short")
        fi
    done < <(git branch --all --format='%(refname:short)' 2>/dev/null)

    local list=""

    # Worktrees first
    if [[ ${#_existing_wt[@]} -gt 0 ]]; then
        for branch in "${_existing_wt[@]}"; do
            # Skip the worktree you're currently inside
            [[ "$branch" == "$CURRENT_BRANCH" ]] && continue

            local info author date msg
            info=$(get_branch_info "$branch")
            author=$(echo "$info" | awk -F"$SEP" '{print $1}')
            date=$(echo "$info" | awk -F"$SEP" '{print $2}')
            msg=$(echo "$info" | awk -F"$SEP" '{print $3}')
            list+=$(printf "[worktree] %-25s %s %-15s %s %-15s %s %s" "$branch" "$SEP" "$author" "$SEP" "$date" "$SEP" "$msg")
            list+=$'\n'
        done
    fi

    # Branches without worktrees
    if [[ ${#_all_branches[@]} -gt 0 ]]; then
        for branch in "${_all_branches[@]}"; do
            [[ -n "${_worktree_map[$branch]+_}" ]] && continue
            # Skip the branch you're currently on
            [[ "$branch" == "$CURRENT_BRANCH" ]] && continue

            local info author date msg
            info=$(get_branch_info "$branch")
            author=$(echo "$info" | awk -F"$SEP" '{print $1}')
            date=$(echo "$info" | awk -F"$SEP" '{print $2}')
            msg=$(echo "$info" | awk -F"$SEP" '{print $3}')
            list+=$(printf "[branch]   %-25s %s %-15s %s %-15s %s %s" "$branch" "$SEP" "$author" "$SEP" "$date" "$SEP" "$msg")
            list+=$'\n'
        done
    fi

    echo "$list"
}

# INFO: fzf loop (supports delete + re-display)
# We loop so that after deleting a worktree with Ctrl-D, the menu refreshes
# and you can keep working. The loop exits on Enter (select) or Esc (cancel).
#
# --print-query + --expect=ctrl-d makes fzf output THREE lines:
#   Line 1: the typed query (what you searched for)
#   Line 2: the key pressed ("ctrl-d" or empty for Enter)
#   Line 3: the selected line

if [[ $# -eq 1 ]]; then
    # Branch name passed as argument — skip fzf entirely
    raw_selected=""
    query="$1"
    key=""
else
    while true; do
        fzf_list=$(build_fzf_list)

        fzf_output=$(echo "$fzf_list" | fzf --ansi \
            --print-query \
            --expect=ctrl-d \
            --prompt="  Worktree > " \
            --header="Enter: select | Ctrl-D: delete worktree | Esc: cancel" \
            2>/dev/null) || true

        query=$(echo "$fzf_output" | sed -n '1p')
        key=$(echo "$fzf_output" | sed -n '2p')
        raw_selected=$(echo "$fzf_output" | sed -n '3p')

        # Esc / Ctrl-C — nothing captured, exit
        [[ -z "$query" && -z "$key" && -z "$raw_selected" ]] && exit 0

        if [[ "$key" == "ctrl-d" && -n "$raw_selected" ]]; then
            # INFO: DELETE WORKTREE
            # Only works on [worktree] entries — branches can't be deleted this way.
            del_tag=$(echo "$raw_selected" | awk '{print $1}')

            if [[ "$del_tag" != "[worktree]" ]]; then
                notify-send -u low -t 6000 "Git Worktree" "Can only delete [worktree] entries, not branches." -i dialog-warning
                continue
            fi

            del_branch=$(echo "$raw_selected" | sed 's/\[[a-z]*\] *//' | awk -F'\\|' '{print $1}' | xargs)

            # Get the path from git worktree list (more reliable than reconstructing)
            del_path=$(git worktree list | grep "\[$del_branch\]" | awk '{print $1}')

            if [[ -z "$del_path" ]]; then
                notify-send -u critical -t 6000 "Git Worktree" "Could not find worktree path for '$del_branch'." -i edit-delete
                continue
            fi

            # Kill any tmux session associated with this worktree
            del_session=$(echo "${PROJECT_NAME}_${del_branch}" | tr './' '__')
            tmux kill-session -t "$del_session" 2>/dev/null || true

            # Remove the worktree from git and delete the directory
            # --force handles worktrees with uncommitted changes
            git worktree remove --force "$del_path" 2>/dev/null || {
                notify-send -u critical -t 6000 "Git Worktree" "Failed to remove worktree. Trying manual cleanup..." -i edit-delete
                git worktree prune
                rm -rf "$del_path"
            }

            notify-send -t 6000 "Git Worktree" "Deleted worktree: $del_branch" -i user-trash-full

            # Loop back to show the refreshed fzf list
            continue
        fi

        # Enter was pressed — break out of the loop to handle selection
        break
    done
fi

# INFO: Rebuild worktree map for selection handling
# After potential deletions in the loop above, we need a fresh worktree map.
declare -A worktree_map
declare -A seen_branches

while IFS= read -r line; do
    wt_path=$(echo "$line" | awk '{print $1}')
    wt_branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')

    if [[ -n "$wt_branch" ]]; then
        [[ "$wt_path" == "$REPO_ROOT" ]] && continue
        worktree_map["$wt_branch"]="$wt_path"
    fi
done < <(git worktree list)

while IFS= read -r branch; do
    branch=$(echo "$branch" | sed 's/^[* ] //' | xargs)
    [[ -z "$branch" ]] && continue
    [[ "$branch" == *"HEAD"* ]] && continue
    short="${branch#origin/}"
    seen_branches["$short"]=1
done < <(git branch --all --format='%(refname:short)' 2>/dev/null)

# INFO: Handle the selection
if [[ -n "$raw_selected" ]]; then
    tag=$(echo "$raw_selected" | awk '{print $1}')
    selected_branch=$(echo "$raw_selected" | sed 's/\[[a-z]*\] *//' | awk -F'\\|' '{print $1}' | xargs)

    if [[ "$tag" == "[worktree]" ]]; then
        selected_path="${worktree_map[$selected_branch]}"

    elif [[ "$tag" == "[branch]" ]]; then
        wt_path="$PARENT_DIR/${PROJECT_NAME}_${selected_branch}"

        if git show-ref --verify --quiet "refs/remotes/origin/$selected_branch" 2>/dev/null &&
           ! git show-ref --verify --quiet "refs/heads/$selected_branch" 2>/dev/null; then
            git worktree add --track -b "$selected_branch" "$wt_path" "origin/$selected_branch"
        else
            git worktree add "$wt_path" "$selected_branch"
        fi

        selected_path="$wt_path"
    fi
else
    selected_branch="$query"

    if [[ -n "${worktree_map[$selected_branch]+_}" ]]; then
        selected_path="${worktree_map[$selected_branch]}"
    elif [[ -n "${seen_branches[$selected_branch]+_}" ]]; then
        wt_path="$PARENT_DIR/${PROJECT_NAME}_${selected_branch}"

        if git show-ref --verify --quiet "refs/remotes/origin/$selected_branch" 2>/dev/null &&
           ! git show-ref --verify --quiet "refs/heads/$selected_branch" 2>/dev/null; then
            git worktree add --track -b "$selected_branch" "$wt_path" "origin/$selected_branch"
        else
            git worktree add "$wt_path" "$selected_branch"
        fi

        selected_path="$wt_path"
    else
        wt_path="$PARENT_DIR/${PROJECT_NAME}_${selected_branch}"
        git worktree add -b "$selected_branch" "$wt_path" HEAD
        selected_path="$wt_path"
    fi
fi

#  INFO: Open in a tmux session
# Each worktree gets its own tmux SESSION named projectname_branch.
# If the session already exists, we just switch to it.
#
# Switch between sessions with Ctrl-b s (list) or Ctrl-b ) / Ctrl-b (.

session_name=$(echo "${PROJECT_NAME}_${selected_branch}" | tr './' '__')
tmux_running=$(pgrep tmux || true)

if [[ -z "${TMUX:-}" ]] && [[ -z "$tmux_running" ]]; then
    tmux new-session -s "$session_name" -c "$selected_path"
    exit 0
fi

if ! tmux has-session -t="$session_name" 2>/dev/null; then
    tmux new-session -ds "$session_name" -c "$selected_path"
fi

if [[ -n "${TMUX:-}" ]]; then
    tmux switch-client -t "$session_name"
else
    tmux attach-session -t "$session_name"
fi
